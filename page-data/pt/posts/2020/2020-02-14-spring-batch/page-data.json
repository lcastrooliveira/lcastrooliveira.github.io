{
    "componentChunkName": "component---src-templates-post-page-template-js",
    "path": "/pt/posts/2020/2020-02-14-spring-batch/",
    "result": {"data":{"mdx":{"id":"126e1ac4-889b-5248-8c5a-d55b8b204824","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"date\": \"2020-02-14T13:32:04.000Z\",\n  \"title\": \"Using Spring Batch to create an ETL for financial information\",\n  \"subtitle\": \"How to make a simple ETL to convert data from a CSV file into a database using Spring Batch\",\n  \"description\": \"How to make a simple ETL to convert data from a CSV file into a database using Spring Batch\",\n  \"tags\": [\"Java\", \"Spring Framework\", \"Spring Batch\", \"ETL\"],\n  \"published\": true,\n  \"language\": \"en\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I've started to play with Spring Batch and ETLs and this is what I've got (so far)\\u2026.\"), mdx(\"p\", null, \"The year of 2019 has been very intense for me because I've had the opportunity to learn a lot about Web development using Java Spring and DevOps culture in general. However, there is a saying: \\\"The more you know, the more you realize you don't know\\\". So here I was looking a way to deepen even further my knowledge about the Spring ecosystem, when I've got curious on Spring Batch project.\"), mdx(\"p\", null, \"For those who don't know Spring Batch is a subproject from Spring framework aimed for batch processing. This project contains many resources in its toolset that allows a systematic, deterministic and trackable execution of batch jobs. An interesting example of application is the use Spring Batch to process a data streaming such as a spreadsheet or a database. And this is the very first example I'm going to show here launching my first article for real in my blog =D\"), mdx(\"p\", null, \"While searching for a nice use case to understand a little more of Spring Batch and since last that last year I was part of a group of study in data science, a university extension program from UNILA, which you can check more about it here \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://medialabfoz.com/gecd/\"\n  }, \"link\"), \", I've come to know the concept of ETL.\"), mdx(\"h2\", null, \"ELT (TL;DR)\"), mdx(\"p\", null, \"A ETL is an acronym which means Extract Transform and Load. The idea itself is very simple and consists in operations that involve big amounts of data. These operations are made basically in three steps: extraction, transformation and loading (or storage). \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Extract,_transform,_load\"\n  }, \"Complete definition on Wikipedia\"), \".\"), mdx(\"p\", null, \"Its use is very common for transferring one, or even many data from a storage dataset into another one. And between the origin and destination it is possible to make transformations in the data such as aggregation, formatting and other things.\"), mdx(\"h2\", null, \"Description of the problem I've hunted\"), mdx(\"p\", null, \"With this concept in mind, I needed a dataset to begin with. Since I really enjoy learning more about financial products, such as fixed income, stocks and real state investment trusts, I've searched something involving these types of data. And then I've discovered that CVM (Brazilian equivalent of American's SEC or UK's FCA) has an \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://dados.cvm.gov.br/\"\n  }, \"open data portal\"), \" where it is possible to download a huge amount of spreadsheets related to investment funds such as daily report, register data and many others.\"), mdx(\"p\", null, \"From the data sets available through CVM, there is a set called \\\"Daily report\\\" (informe di\\xE1rio), which according to CVM it has financial statements such as:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Market Cap\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Net worth\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Single share value\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Fundraising during the day\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Reclaims paid during the day\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Number of shareholders\")), mdx(\"p\", null, \"I've downloaded a spreadsheet of a random day and boom! A CSV with more than 200,000 lines of structured data. Perfect to roll up my sleeves and starting to play. \"), mdx(\"p\", null, \"Every row in the CSV file represents information about an investment fund in a given day. From the dozens of columns available in the spreadsheet, I've peeked some to use on my ETL solution such as:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"CNPJ of the funds' issuing company (CNPJ is a Brazilian equivalent of American EIN or UK's Employer Number)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Referenced date\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Total Value\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Quota(share) Value\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Net Worth\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Fundraising during the day(total of deposits)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Reclaims paid during the day(total of withdraws)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Number of shareholders (quote owners)\")), mdx(\"p\", null, \"For the first step I thought in doing only a simple ETL, which means load the information from de CSV and store them in a MySQL database. But in order to do at least one thing in the transformation step, I've just simply removed CPNJ field formatting by stripping dots and slashes and saving only digits. In Brazil a CNPJ is often represented like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"XX.XXX.XXX/0001-XX\"), \", so I've just converted to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"XXXXXXXX0001XX\"), \".\"), mdx(\"p\", null, \"The napkin sketch of my solution were something like that:\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://i.imgur.com/4ID6lG9.png\"\n  }, mdx(\"img\", {\n    parentName: \"a\",\n    \"src\": \"https://i.imgur.com/4ID6lG9.png\",\n    \"alt\": \"ETL Schema\",\n    \"title\": \"ETL Schema\"\n  }))), mdx(\"p\", null, \"The idea is, read the CSV file, performing an ETL using Spring Batch, save information in database table using Spring data and finally use Spring Web to publish the information in JSON format through an API.\"), mdx(\"p\", null, \"The data schema of the database entity I've created into the database is the following:\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://i.imgur.com/Wp41TkJ.png\"\n  }, mdx(\"img\", {\n    parentName: \"a\",\n    \"src\": \"https://i.imgur.com/Wp41TkJ.png\",\n    \"alt\": \"DailyInform\",\n    \"title\": \"Daily Inform\"\n  }))), mdx(\"p\", null, \"Now that the general idea and architecture of the solution is shown, let's write a bit of code!\"), mdx(\"h2\", null, \"Step 1, making my \\\"Hello World\\\" with Spring Batch\"), mdx(\"p\", null, \"In order to use Spring Batch, first you need to insert its dependencies into your project. You can begin by creating a project in Spring Initializr by picking the following projects:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Spring boot starter data jpa: (to connect to the database)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Spring boot starter web: (to create the web layer responsible to expose data via an API REST using JSON).\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"mySql-connector-java: For this tutorial I've chosen MySQL but any other relational database will do.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"spring-boot-starter-batch: The shining star of the solution, it contains the necessary classes to use Spring Batch.\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://i.imgur.com/SwwyBT1.png\"\n  }, mdx(\"img\", {\n    parentName: \"a\",\n    \"src\": \"https://i.imgur.com/SwwyBT1.png\",\n    \"alt\": \"SpringInitializr\",\n    \"title\": \"Spring Initializr\"\n  }))), mdx(\"p\", null, \"Once the Zip file is downloaded, just open it in your favorite IDE and start coding!\"), mdx(\"p\", null, \"First it is necessary to create the entity \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DailyInform\"), \", that will be the final form where the converted information from the spreadsheet will be stored as table in the database.\"), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"java\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"import javax.persistence.*;\\nimport javax.validation.constraints.NotNull;\\nimport java.io.Serializable;\\nimport java.math.BigDecimal;\\nimport java.time.LocalDate;\\n\\n@Entity\\n@Table(indexes = {\\n       @Index(columnList = \\\"cnpj\\\", name = \\\"cnpj_hidx\\\"),\\n       @Index(columnList = \\\"referenceDate\\\", name = \\\"reference_date_hidx\\\")},\\n       uniqueConstraints = @UniqueConstraint(columnNames = { \\\"cnpj\\\", \\\"referenceDate\\\" }))\\npublic class DailyInform implements Serializable {\\n\\n   @Id\\n   @GeneratedValue(strategy = GenerationType.AUTO)\\n   private Long id;\\n\\n   @NotNull\\n   @CNPJ\\n   @Column(nullable = false)\\n   private String cnpj;\\n\\n   @NotNull\\n   @Column(nullable = false)\\n   private LocalDate referenceDate;\\n\\n   @NotNull\\n   @Column(nullable = false)\\n   private BigDecimal totalValue;\\n\\n   @NotNull\\n   @Column(nullable = false)\\n   private BigDecimal quotaValue;\\n\\n   @NotNull\\n   @Column(nullable = false)\\n   private BigDecimal netWorth;\\n\\n   @NotNull\\n   @Column(nullable = false)\\n   private BigDecimal totalDeposits;\\n\\n   @NotNull\\n   @Column(nullable = false)\\n   private BigDecimal totalWithdrawals;\\n\\n   @NotNull\\n   @Column(nullable = false)\\n   private Long numberOfQuotaHolders;\\n\\n   public DailyInform() {};\\n\\n   public DailyInform(String cnpj, LocalDate referenceDate,\\n                      BigDecimal totalValue, BigDecimal quotaValue,\\n                      BigDecimal netWorth, BigDecimal totalDeposits,\\n                      BigDecimal totalWithdrawals, Long numberOfQuotaHolders) {\\n       this.cnpj = cnpj;\\n       this.referenceDate = referenceDate;\\n       this.totalValue = totalValue;\\n       this.quotaValue = quotaValue;\\n       this.netWorth = netWorth;\\n       this.totalDeposits = totalDeposits;\\n       this.totalWithdrawals = totalWithdrawals;\\n       this.numberOfQuotaHolders = numberOfQuotaHolders;\\n   }\\n\\n   @Override\\n   public String toString() {\\n       return \\\"DailyInform{\\\" +\\n               \\\"cnpj='\\\" + cnpj + '\\\\'' +\\n               \\\", referenceDate=\\\" + referenceDate +\\n               \\\", quotaValue=\\\" + quotaValue +\\n               '}';\\n   }\\n   // .... Getters/Setters\\n}\"), \"\\n        \"), mdx(\"p\", null, \"Notice that this is an elementary JPA entity just to show the concepts. I've also added some indexes to improve query performance.\"), mdx(\"p\", null, \"The batch processing in Spring is executed through Jobs. A job is made of Steps that define successive tasks of reading, transformation and writing (for this tutorial I've made a Job with a single Step). The Step basically has three elements:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"A reader: Defines what and how is going to be read. In the step it is defined from where that data will come (in this case a spreadsheet), and which columns will be digested.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"A processor: Defines a transformation operation the read data will have to go through until is ready to be written. It receives an entry object and returns another object.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"A writer: It defines where the just processed data will be written, in this tutorial we will use a Repository bean to write information into the database. \")), mdx(\"p\", null, \"To use a Job in SpringBatch it is necessary to configure it first. The snippet below is an example of a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@Configuration\"), \" bean (the complete code you'll find in my GitHub):\"), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"java\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"@Configuration\\n@EnableBatchProcessing\\npublic class SpringBatchConfiguration {\\n\\n   @Bean\\n   public Job job(JobBuilderFactory jobBuilderFactory,\\n                  StepBuilderFactory stepBuilderFactory,\\n                  ItemReader<DailyInform> itemReader,\\n                  ItemProcessor<DailyInform, DailyInform> itemProcessor,\\n                  ItemWriter<DailyInform> itemWriter) {\\n\\n       Step step = stepBuilderFactory.get(\\\"ETL-file-load\\\")\\n               .<DailyInform, DailyInform>chunk(1000)\\n               .reader(itemReader)\\n              .processor(itemProcessor)\\n               .writer(itemWriter)\\n               .build();\\n\\n       return jobBuilderFactory.get(\\\"ETL-Load\\\")\\n                               .incrementer(new RunIdIncrementer())\\n                               .start(step)\\n                               .build();\\n   }\\n   // more beans will come\\n}\\n\"), \"\\n        \"), mdx(\"p\", null, \"As it can be seen on line 25, it is necessary to use an annotation \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@EnableBatchProcessing\"), \" to habilitate Spring Batch in the project. The Job is exposed to the application through a bean, being managed by the Spring Container. The method \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"job\"), \" receive five parameters: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"jobBuilderFactory\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"stepBuilderFactory\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"itemReader\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"itemProcessor\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"itemWriter\"), \". The factories are injected by Spring itself, and it's up to us to define other parameters through beans in the application. Once defined, Spring can inject them into the method and create the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Job\"), \". Notice that reader, processor and writer types are strongly typed according to the modeled entity \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DailyInform\"), \". It is perfectly possible to model a flux where reading is a type, converted to another type during processing and later written in the write stage. But in order to keep things simple in this tutorial, I will stick with the idea to keep the same type during the whole cycle.\"), mdx(\"p\", null, \"Thanks to dependency injection, Spring is able to assemble the Job using a reader, processor and writer that will also be application beans. I'm going to explain how they are created and the details of each one of them in the sessions below.\"), mdx(\"h2\", null, \"Step 2 - Creating the reading bean\"), mdx(\"p\", null, \"We can create a reading bean from class \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FlatFileItemReader<T>\"), \", a class that indirectly implements the interface \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ItemReader<T>\"), \". The easiness of using this class comes from its design specially made for reading files row by row (perfect for this CSV example). Its configuration is relatively simple, however it demands the creation of another auxiliary bean. An implementation example follows:\"), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"java\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"@Bean\\npublic FlatFileItemReader<DailyInform> fileItemReader(@Value(\\\"${input}\\\") Resource resource) {\\n   FlatFileItemReader<DailyInform> fileItemReader = new FlatFileItemReader<>();\\n   fileItemReader.setResource(resource);\\n   fileItemReader.setEncoding(\\\"ISO-8859-3\\\");\\n   fileItemReader.setName(\\\"CSV-Reader\\\");\\n   fileItemReader.setLinesToSkip(1);\\n   fileItemReader.setLineMapper(lineMapper());\\n   return fileItemReader;\\n}\"), \"\\n        \"), mdx(\"p\", null, \"In whitch:\"), mdx(\"p\", null, \"Input: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Resource\"), \" (a reference to the .csv file), here I've set up the path in an environment variable for convenience.\"), mdx(\"p\", null, \"Output: An object from type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FlatFileItemReader<DailyInform>\"), \" where I define:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The resource to be read.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The file encoding, in this case I've discovered that the spreadsheet is not in UTF-8, therefore I needed to inform the correct encoding so there were no misreading parsing for special characters from Portuguese such as \\xE0, \\xF3 and \\xE3 for example.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Name of this bean: Probably used by Spring for an internal index of this reader.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Jumping lines: I've set up the value \\\"1\\\" so it skips the header and goes straight to the data.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"LineMapper\"), \": The auxiliary bean need to configure the reading policies, its creation will be detailed below.\")), mdx(\"h3\", null, \"Assembling the LineMapper\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"LineMapper\"), \" is the bean that basically defines the reading logic such as: What character is the column delimiter, the column names and also how to convert to an object each row read. Its construction goes as follows:\"), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"java\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"@Bean\\npublic LineMapper<DailyInform> lineMapper() {\\n   DefaultLineMapper<DailyInform> defaultLineMapper = new DefaultLineMapper<>();\\n   DelimitedLineTokenizer lineTokenizer = new DelimitedLineTokenizer();\\n\\n   lineTokenizer.setDelimiter(\\\";\\\");\\n\\n   lineTokenizer.setNames(\\\"CNPJ_FUNDO\\\",\\n                          \\\"DT_COMPTC\\\",\\n                          \\\"VL_TOTAL\\\",\\n                          \\\"VL_QUOTA\\\",\\n                          \\\"VL_PATRIM_LIQ\\\",\\n                          \\\"CAPTC_DIA\\\",\\n                          \\\"RESG_DIA\\\",\\n                          \\\"NR_COTST\\\");\\n   lineTokenizer.setStrict(false);\\n\\n   DailyInformFieldSetMapper dailyInformFieldSetMapper = new DailyInformFieldSetMapper();\\n\\n   defaultLineMapper.setLineTokenizer(lineTokenizer);\\n   defaultLineMapper.setFieldSetMapper(dailyInformFieldSetMapper);\\n\\n   return defaultLineMapper;\\n}\\n\"), \"\\n        \"), mdx(\"p\", null, \"The returned object by this method is an instance of class \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DefaultLineMaper\"), \", which implements the interface \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"LineMapper\"), \", where is configured:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The delimiter: in the case of the downloaded CSV file from CVM, the character \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \";\"), \" has been used to split the data for each column.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Define the tokens (or names) of each column that will be read, as well how many will be processed. Later these names are going to be used by the bean responsible to insert the information of each line in a POJO \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"DailyInform\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Set strict reading: In case of true, every line needs to have the exact number of columns, if this option is false SpringBatch accepts reading lines which may not have the same number of columns as defined by the tokens. When this happens, the missing values will be filled with empty, if there are more columns than tokens they will simply be ignored.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"fieldsetmapper\"), \": Bean which defines how the data read from rows will be converted into a POJO. In this case I've created a class called \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"DailyInformFieldSetMapper\"), \" responsible for this job.\")), mdx(\"h3\", null, \"The DailyInformFieldSetMapper (because there is no such thing as magic)\"), mdx(\"p\", null, \"This class implements the interface \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FieldSetMapper<T>\"), \", that by its contract, demands the implementation of the method \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<T> mapFieldSet(FieldSet fieldSet)\"), \", this method receives as a parameter a line read by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"LineMapper\"), \" and it's responsible to for setting the attributes from class \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DailyInform\"), \" with each token data. This is the very heart of data conversion from a CSV line into a Java object (that's why I've said before that there's no such thing as magic xD). The class has only the method \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mapFieldSet\"), \" and stands as below:\"), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"java\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"public class DailyInformFieldSetMapper implements FieldSetMapper<DailyInform> {\\n\\n   @Override\\n   public DailyInform mapFieldSet(FieldSet fieldSet) throws BindException {\\n       final DailyInform dailyInform = new DailyInform();\\n       dailyInform.setCnpj(fieldSet.readString(\\\"CNPJ_FUNDO\\\"));\\n       dailyInform.setReferenceDate(fieldSet.readDate(\\\"DT_COMPTC\\\")\\n                  .toInstant().atZone(ZoneId.systemDefault()).toLocalDate());\\n       dailyInform.setTotalValue(fieldSet.readBigDecimal(\\\"VL_TOTAL\\\"));\\n       dailyInform.setQuotaValue(fieldSet.readBigDecimal(\\\"VL_QUOTA\\\"));\\n       dailyInform.setNetWorth(fieldSet.readBigDecimal(\\\"VL_PATRIM_LIQ\\\"));\\n       dailyInform.setTotalDeposits(fieldSet.readBigDecimal(\\\"CAPTC_DIA\\\"));\\n       dailyInform.setTotalWithdrawals(fieldSet.readBigDecimal(\\\"RESG_DIA\\\"));\\n       dailyInform.setNumberOfQuotaHolders(fieldSet.readLong(\\\"NR_COTST\\\"));\\n       return dailyInform;\\n   }\\n}\\n\"), \"\\n        \"), mdx(\"p\", null, \"With those steps done, everything is set and configured for the reading step, now there are only two remaining steps: transformation and writing. Fortunately they are simpler as I'll show below.\"), mdx(\"h2\", null, \"Step 3 - Configuring the Processor\"), mdx(\"p\", null, \"The class \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DailyInformProcessor\"), \" is responsible for transforming operations upon the object \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DailyInform\"), \". In this stage is possible to perform all kinds of operations such as apply calculations, formatting, data aggregation and even convert the output to another completely different object. In the case of this tutorial, just as an example I've used this step to format the CNPJ value from companies by removing dots and slashes. For that I borrowed a help from a library called \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://stella.caelum.com.br/\"\n  }, \"Alura Stella\"), \", which contain many helping functions to manipulate Brazilian documents. Besides, I haven't modified the type of the output object (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DailyInform\"), \" comes in, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DailyInform\"), \" comes out). The class has a very simple implementation and stands as follows:\"), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"java\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"@Component\\npublic class DailyInformProcessor implements ItemProcessor<DailyInform, DailyInform> {\\n\\n   @Autowired\\n   private CNPJFormatter cnpjFormatter;\\n\\n   @Override\\n   public DailyInform process(DailyInform dailyInform) throws Exception {\\n       dailyInform.setCnpj(cnpjFormatter.unformat(dailyInform.getCnpj()));\\n       return dailyInform;\\n   }\\n}\\n\"), \"\\n        \"), mdx(\"p\", null, \"Notice that it's necessary to implement the methods \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"process\"), \" from interface \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ItemProcessor\"), \", very self-explanatory.\"), mdx(\"p\", null, \"Lastly, there's only the writing stage to build.\"), mdx(\"h2\", null, \"Step 4 - Configuring Writing\"), mdx(\"p\", null, \"First, let's create a repository for the entity \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DailyInform\"), \" which is going to be used by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Writer\"), \" to writer data into the Database.\"), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"java\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"@Repository\\npublic interface DailyInformRepository extends JpaRepository<DailyInform, Long> {\\n   List<DailyInform> findDistinctByCnpj(String cnpj);\\n}\\n\"), \"\\n        \"), mdx(\"p\", null, \"It's a simple repository used by Spring Data without any hidden mystery. I've just added a method to find daily inform via CNPJ because I've created an endpoint in the web layer that shows results by company.\"), mdx(\"p\", null, \"Created the repository, now it is just to create the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Writer\"), \", which basically is a Spring component that implements the interface \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ItemWeriter\"), \":\"), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"java\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"@Component\\npublic class DBWriter implements ItemWriter<DailyInform> {\\n\\n   private final DailyInformRepository dailyInformRepository;\\n\\n   @Autowired\\n   public DBWriter(DailyInformRepository dailyInformRepository) {\\n       this.dailyInformRepository = dailyInformRepository;\\n   }\\n\\n   @Override\\n   public void write(List<? extends DailyInform> list) {\\n       dailyInformRepository.saveAll(list);\\n   }\\n}\\n\"), \"\\n        \"), mdx(\"p\", null, \"The only method that the interface demands implementation is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"write\"), \". This method gets a list with data (the chunks that were transformed from the previous step), which in turn I send to the database using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DailyInformRepository\"), \", by injecting the latter into the class by the attribute \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dailyInformRepository\"), \". The JPA repositories have a method called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"saveAll\"), \" which accepts a Java collection that is going to be saved in the database. By performing these steps the information is persisted, and the data finally get to its final destination =D\"), mdx(\"h2\", null, \"Bonus - Web Layer\"), mdx(\"p\", null, \"Once the data has been persisted into the database, it is fairly simple to create a web layer to expose the information in JSON format. If you're up to follow a very traditional architecture and want to follow a N-layers style, you can create a Service and a Controller. The snippets below show how to do that:\"), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"java\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"@Service\\npublic class FundsService {\\n\\n   private final DailyInformRepository dailyInformRepository;\\n\\n   @Autowired\\n   public FundsService(DailyInformRepository dailyInformRepository) {\\n       this.dailyInformRepository = dailyInformRepository;\\n   }\\n\\n   @Transactional(readOnly = true)\\n   public List<DailyInform> getDailyInformByCNPJ(String cnpj) {\\n       return dailyInformRepository.findDistinctByCnpj(cnpj);\\n   }\\n}\"), \"\\n        \"), mdx(\"p\", null, \"And the controller:\"), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"java\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"@RestController\\n@RequestMapping(\\\"/api/daily-informs\\\")\\npublic class FundsController {\\n\\n   private final FundsService fundsService;\\n\\n   @Autowired\\n   public FundsController(FundsService fundsService) {\\n       this.fundsService = fundsService;\\n   }\\n\\n   @GetMapping(\\\"/{cnpj}\\\")\\n   public ResponseEntity<List<DailyInform>> all(@PathVariable(\\\"cnpj\\\") String cnpj) {\\n       return ResponseEntity.of(Optional.of(fundsService.getDailyInformByCNPJ(cnpj)));\\n   }\\n}\\n\"), \"\\n        \"), mdx(\"p\", null, \"About these two components I have the following points:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Notice that I inject the repository into the service and the service into the controller. Following the architecture guidelines of N-layers, exposing the data layer only to the service layer.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"In \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"FundsService\"), \" I've inserted an annotation \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"@Transaction\"), \" with its parameter \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"readonly\"), \" set to true. This way I tell Spring to open a transactional context in the method that won't perform writing operations into the database, achieving a transactional behavior with a performance gain.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"In the controller I've decided to use CNPJ as a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"PathParam\"), \", but there are other ways this can be done (through a non-nullable query parameter for example).\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Lastly I've injected all components through class constructors, I prefer doing this way because I can declare my dependencies as \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"final\"), \", so the class attributes are immutable.\")), mdx(\"h2\", null, \"Firing in up!\"), mdx(\"p\", null, \"With all said and done now it's time to run this batch. To run the job as soon as Spring starts I've implemented a interface called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CommandLineRunner\"), \" in the main class which runs the configured job. The result is as follows:\"), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"java\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"@SpringBootApplication\\npublic class BatchProcessingApplication implements CommandLineRunner {\\n\\n   @Bean\\n   public CNPJFormatter cnpjFormatter() {\\n       return new CNPJFormatter();\\n   }\\n\\n   @Autowired\\n   private JobLauncher jobLauncher;\\n\\n   @Autowired\\n   private Job job;\\n\\n   public static void main(String[] args) {\\n       SpringApplication.run(BatchProcessingApplication.class, args);\\n   }\\n\\n   @Override\\n   public void run(String... args) throws Exception {\\n       jobLauncher.run(job, new JobParameters());\\n   }\\n}\\n\"), \"\\n        \"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"job\"), \" bean is detected automatically by Spring, and it comes from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Job\"), \" created in the configuration file, besides, it is necessary a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"JobLaucher\"), \" which is nothing more that a bean provided by Spring you can use it to launch your job. We do this by inserting the attribute \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"job\"), \" autowired inside the method \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"run\"), \" from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"jobLauncher\"), \". The parameter \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"JobParameters\"), \" is basically a Wrapper with a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Map<String, Object>\"), \" which allows you to send parameters to the job going to be launched (it's not going to be used at this tutorial, so we can leave it as an empty instance).\"), mdx(\"p\", null, \"With this done, the application is ready to be run (by running the main method). Check that your database is running and it's reachable for your application.\"), mdx(\"p\", null, \"In my machine it took about 90 minutes to process 200k lines of data.\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://i.imgur.com/gIyfW6P.png\"\n  }, mdx(\"img\", {\n    parentName: \"a\",\n    \"src\": \"https://i.imgur.com/gIyfW6P.png\",\n    \"alt\": \"Results Cmd\",\n    \"title\": \"Resultados em execução\"\n  }))), mdx(\"p\", null, \"This is how the database looks like:\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://i.imgur.com/jf34chM.png\"\n  }, mdx(\"img\", {\n    parentName: \"a\",\n    \"src\": \"https://i.imgur.com/jf34chM.png\",\n    \"alt\": \"Results DB\",\n    \"title\": \"Resultados no banco\"\n  }))), mdx(\"p\", null, \"This is the result by calling the endpoint I've created to bring results by CNPJ. Cool isn't it ? XD\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://i.imgur.com/XmSLgAA.png\"\n  }, mdx(\"img\", {\n    parentName: \"a\",\n    \"src\": \"https://i.imgur.com/XmSLgAA.png\",\n    \"alt\": \"Results JSON\",\n    \"title\": \"Resultados JSON\"\n  }))), mdx(\"h2\", null, \"Conclusion\"), mdx(\"p\", null, \"Wow if you've got so far congratulations! Hehehe this tutorial got bigger than I thought, but is fine to start this blog with the right foot. It's obvious that there is much to improve, but now I have \\\"a north\\\" and I expect to write 2 articles here every month.\"), mdx(\"p\", null, \"Regarding the application, well it worked, but I believe that there is way too many improvement points. Some stuff I've already discovered how to improve and can write about it in another article. An example is what to do if there's a line with irregular information in the spreadsheet? The way it stands now the whole job stops running. Since this is not desirable, it is necessary to define a tolerance policy and error registration. Another thing that is also possible to do is running the execution in parallel, how to make more efficient? Is there additional database configs that can be made? Stay tuned for more content coming up.\"), mdx(\"p\", null, \"I hope you've enjoyed my first article and I ask you to share with your collegues. Feel free to comment, the more feedback received the better!\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/lcastrooliveira/funds_daily_report\"\n  }, \"Application GitHub\")), mdx(\"h3\", null, \"References\"), mdx(\"p\", null, \"For more reference pleas go the following sites. I've made this tutorial based on them.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://maven.apache.org/guides/index.html\"\n  }, \"Official Apache Maven documentation\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/maven-plugin/\"\n  }, \"Spring Boot Maven Plugin Reference Guide\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/reference/htmlsingle/#howto-batch-applications\"\n  }, \"Spring Batch\"))), mdx(\"h3\", null, \"Guide\"), mdx(\"p\", null, \"This guide also is very good and comes from Spring itself, I recommend for everyone who wants that to learn further.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://spring.io/guides/gs/batch-processing/\"\n  }, \"Creating a Batch Service\"))), mdx(\"p\", null, \"Cheers;\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Using Spring Batch to create an ETL for financial information","language":"en","description":"How to make a simple ETL to convert data from a CSV file into a database using Spring Batch","date":"2020-02-14T13:32:04.000Z"},"fields":{"slug":"/posts/2020/2020-02-14-spring-batch/"}}},"pageContext":{"id":"126e1ac4-889b-5248-8c5a-d55b8b204824","locale":"pt","hrefLang":"pt-BR","originalPath":"/posts/2020/2020-02-14-spring-batch/","dateFormat":"DD/MM/YYYY"}},
    "staticQueryHashes": ["1239077767","2744294623","2744905544","3280999885","4024388462"]}